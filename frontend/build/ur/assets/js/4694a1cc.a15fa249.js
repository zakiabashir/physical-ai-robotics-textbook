"use strict";(globalThis.webpackChunkphysical_ai_robotics_textbook=globalThis.webpackChunkphysical_ai_robotics_textbook||[]).push([[1666],{1607:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>p,contentTitle:()=>l,default:()=>m,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"chapter-4/lesson-1","title":"Lesson 4.1: Humanoid Robot Kinematics","description":"Understanding the mathematics and mechanics of humanoid robot movement","source":"@site/docs/chapter-4/lesson-1.mdx","sourceDirName":"chapter-4","slug":"/chapter-4/lesson-1","permalink":"/ur/docs/chapter-4/lesson-1","draft":false,"unlisted":false,"editUrl":"https://github.com/physical-ai/physical-ai-robotics-textbook/tree/main/docs/chapter-4/lesson-1.mdx","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Lesson 4.1: Humanoid Robot Kinematics","description":"Understanding the mathematics and mechanics of humanoid robot movement","sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Lesson 3.3: Conversational Robots","permalink":"/ur/docs/chapter-3/lesson-3"},"next":{"title":"Lesson 4.2: Biped Locomotion","permalink":"/ur/docs/chapter-4/lesson-2"}}');var a=t(4848),r=t(8453),o=t(2948);const s={title:"Lesson 4.1: Humanoid Robot Kinematics",description:"Understanding the mathematics and mechanics of humanoid robot movement",sidebar_position:1},l="Lesson 4.1: Humanoid Robot Kinematics",p={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction to Humanoid Kinematics",id:"introduction-to-humanoid-kinematics",level:2},{value:"Mathematical Foundations",id:"mathematical-foundations",level:2},{value:"1. Homogeneous Transformations",id:"1-homogeneous-transformations",level:3},{value:"2. Denavit-Hartenberg Parameters",id:"2-denavit-hartenberg-parameters",level:3},{value:"Inverse Kinematics",id:"inverse-kinematics",level:2},{value:"1. Numerical IK Solutions",id:"1-numerical-ik-solutions",level:3},{value:"Lab Exercise: Humanoid Motion Planning",id:"lab-exercise-humanoid-motion-planning",level:2},{value:"Objective",id:"objective",level:3},{value:"Setup",id:"setup",level:3},{value:"Implementation",id:"implementation",level:3},{value:"Testing the Motion Planner",id:"testing-the-motion-planner",level:3},{value:"Expected Results",id:"expected-results",level:3},{value:"Advanced Topics",id:"advanced-topics",level:2},{value:"1. Kinematic Redundancy",id:"1-kinematic-redundancy",level:3},{value:"2. Singularity Analysis",id:"2-singularity-analysis",level:3},{value:"Key Takeaways",id:"key-takeaways",level:2},{value:"Summary",id:"summary",level:2},{value:"Quiz",id:"quiz",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components},{DiagramComponent:t,Quiz:i}=e;return t||_("DiagramComponent",!0),i||_("Quiz",!0),(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"lesson-41-humanoid-robot-kinematics",children:"Lesson 4.1: Humanoid Robot Kinematics"})}),"\n",(0,a.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,a.jsxs)("div",{className:"learning-objectives",children:[(0,a.jsx)(e.p,{children:"After completing this lesson, you will be able to:"}),(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Derive forward and inverse kinematics for humanoid robots"}),"\n",(0,a.jsx)(e.li,{children:"Implement Denavit-Hartenberg (DH) parameters for robot arms and legs"}),"\n",(0,a.jsx)(e.li,{children:"Solve kinematic equations for complex joint chains"}),"\n",(0,a.jsx)(e.li,{children:"Understand singularities and workspace constraints"}),"\n",(0,a.jsx)(e.li,{children:"Apply kinematic control to humanoid robot locomotion"}),"\n"]})]}),"\n",(0,a.jsx)(e.h2,{id:"introduction-to-humanoid-kinematics",children:"Introduction to Humanoid Kinematics"}),"\n",(0,a.jsx)(e.p,{children:"Humanoid robots require sophisticated kinematic models to achieve human-like movement. With over 30 degrees of freedom, these systems represent some of the most complex kinematic chains in robotics."}),"\n",(0,a.jsx)(t,{title:"Humanoid Robot Kinematic Structure",children:(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-mermaid",children:'graph TB\n    subgraph "Upper Body"\n        A[Torso] --\x3e B[Right Shoulder]\n        A --\x3e C[Left Shoulder]\n        A --\x3e D[Head]\n        B --\x3e E[Right Elbow]\n        C --\x3e F[Left Elbow]\n        E --\x3e G[Right Wrist]\n        F --\x3e H[Left Wrist]\n    end\n\n    subgraph "Lower Body"\n        A --\x3e I[Right Hip]\n        A --\x3e J[Left Hip]\n        I --\x3e K[Right Knee]\n        J --\x3e L[Left Knee]\n        K --\x3e M[Right Ankle]\n        L --\x3e N[Left Ankle]\n        M --\x3e O[Right Foot]\n        N --\x3e P[Left Foot]\n    end\n\n    subgraph "Kinematic Chains"\n        Q[3-DOF Shoulder]\n        R[1-DOF Elbow]\n        S[2-DOF Wrist]\n        T[3-DOF Hip]\n        U[1-DOF Knee]\n        V[2-DOF Ankle]\n    end\n'})})}),"\n",(0,a.jsx)(e.h2,{id:"mathematical-foundations",children:"Mathematical Foundations"}),"\n",(0,a.jsx)(e.h3,{id:"1-homogeneous-transformations",children:"1. Homogeneous Transformations"}),"\n",(0,a.jsx)(e.p,{children:"Homogeneous transforms combine rotation and translation in 4x4 matrices."}),"\n",(0,a.jsx)(o.A,{title:"Homogeneous Transform Implementation",language:"python",children:(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'import numpy as np\nfrom typing import Tuple, List\n\nclass HomogeneousTransform:\n    """4x4 homogeneous transformation matrix operations"""\n\n    @staticmethod\n    def create_rotation_x(theta: float) -> np.ndarray:\n        """Create rotation matrix around X axis"""\n        c, s = np.cos(theta), np.sin(theta)\n        return np.array([\n            [1, 0, 0, 0],\n            [0, c, -s, 0],\n            [0, s, c, 0],\n            [0, 0, 0, 1]\n        ])\n\n    @staticmethod\n    def create_rotation_y(theta: float) -> np.ndarray:\n        """Create rotation matrix around Y axis"""\n        c, s = np.cos(theta), np.sin(theta)\n        return np.array([\n            [c, 0, s, 0],\n            [0, 1, 0, 0],\n            [-s, 0, c, 0],\n            [0, 0, 0, 1]\n        ])\n\n    @staticmethod\n    def create_rotation_z(theta: float) -> np.ndarray:\n        """Create rotation matrix around Z axis"""\n        c, s = np.cos(theta), np.sin(theta)\n        return np.array([\n            [c, -s, 0, 0],\n            [s, c, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1]\n        ])\n\n    @staticmethod\n    def create_translation(x: float, y: float, z: float) -> np.ndarray:\n        """Create translation matrix"""\n        return np.array([\n            [1, 0, 0, x],\n            [0, 1, 0, y],\n            [0, 0, 1, z],\n            [0, 0, 0, 1]\n        ])\n\n    @staticmethod\n    def from_rpy(roll: float, pitch: float, yaw: float,\n                 x: float = 0, y: float = 0, z: float = 0) -> np.ndarray:\n        """Create transform from roll-pitch-yaw angles"""\n        Rx = HomogeneousTransform.create_rotation_x(roll)\n        Ry = HomogeneousTransform.create_rotation_y(pitch)\n        Rz = HomogeneousTransform.create_rotation_z(yaw)\n        T = HomogeneousTransform.create_translation(x, y, z)\n\n        return T @ Rz @ Ry @ Rx\n\n    @staticmethod\n    def decompose(T: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:\n        """Decompose transform into rotation and translation"""\n        R = T[:3, :3]\n        t = T[:3, 3]\n        return R, t\n\n    @staticmethod\n    def to_rpy(T: np.ndarray) -> Tuple[float, float, float]:\n        """Convert transform to roll-pitch-yaw angles"""\n        R = T[:3, :3]\n\n        # Extract Euler angles (ZYX convention)\n        if abs(R[2, 0]) != 1:\n            pitch = -np.arcsin(R[2, 0])\n            cos_pitch = np.cos(pitch)\n            roll = np.arctan2(R[2, 1] / cos_pitch, R[2, 2] / cos_pitch)\n            yaw = np.arctan2(R[1, 0] / cos_pitch, R[0, 0] / cos_pitch)\n        else:\n            # Gimbal lock case\n            yaw = 0\n            if R[2, 0] == -1:\n                pitch = np.pi / 2\n                roll = np.arctan2(R[0, 1], R[0, 2])\n            else:\n                pitch = -np.pi / 2\n                roll = np.arctan2(-R[0, 1], -R[0, 2])\n\n        return roll, pitch, yaw\n'})})}),"\n",(0,a.jsx)(e.h3,{id:"2-denavit-hartenberg-parameters",children:"2. Denavit-Hartenberg Parameters"}),"\n",(0,a.jsx)(e.p,{children:"DH parameters provide a systematic way to describe kinematic chains."}),"\n",(0,a.jsx)(o.A,{title:"DH Parameter System",language:"python",children:(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'import numpy as np\nfrom typing import List, Dict\n\nclass DHParameter:\n    """Denavit-Hartenberg parameter for a single joint"""\n    def __init__(self, a: float, alpha: float, d: float, theta: float,\n                 joint_type: str = \'revolute\'):\n        self.a = a  # Link length (distance along X)\n        self.alpha = alpha  # Link twist (rotation around X)\n        self.d = d  # Link offset (distance along Z)\n        self.theta = theta  # Joint angle (rotation around Z)\n        self.joint_type = joint_type  # \'revolute\' or \'prismatic\'\n\n    def get_transformation(self, q: float = None) -> np.ndarray:\n        """Get transformation matrix for this joint"""\n        if self.joint_type == \'revolute\':\n            theta = self.theta + q if q is not None else self.theta\n            d = self.d\n        else:  # prismatic\n            theta = self.theta\n            d = self.d + q if q is not None else self.d\n\n        # DH transformation matrix\n        ct = np.cos(theta)\n        st = np.sin(theta)\n        ca = np.cos(self.alpha)\n        sa = np.sin(self.alpha)\n\n        return np.array([\n            [ct, -st*ca, st*sa, self.a*ct],\n            [st, ct*ca, -ct*sa, self.a*st],\n            [0, sa, ca, d],\n            [0, 0, 0, 1]\n        ])\n\nclass KinematicChain:\n    """Kinematic chain using DH parameters"""\n\n    def __init__(self):\n        self.dh_parameters: List[DHParameter] = []\n        self.num_joints = 0\n\n    def add_joint(self, a: float, alpha: float, d: float, theta: float,\n                  joint_type: str = \'revolute\'):\n        """Add a joint to the kinematic chain"""\n        self.dh_parameters.append(\n            DHParameter(a, alpha, d, theta, joint_type)\n        )\n        self.num_joints += 1\n\n    def forward_kinematics(self, q: np.ndarray) -> np.ndarray:\n        """Calculate forward kinematics"""\n        if len(q) != self.num_joints:\n            raise ValueError(f"Expected {self.num_joints} joint values, got {len(q)}")\n\n        T = np.eye(4)\n\n        for i, dh_param in enumerate(self.dh_parameters):\n            T = T @ dh_param.get_transformation(q[i])\n\n        return T\n\n    def get_jacobian(self, q: np.ndarray) -> np.ndarray:\n        """Calculate the geometric Jacobian"""\n        J = np.zeros((6, self.num_joints))\n\n        # Forward kinematics for each joint\n        T_base_to_ee = np.eye(4)\n        T_list = [T_base_to_ee]\n\n        for i, dh_param in enumerate(self.dh_parameters):\n            T_joint = dh_param.get_transformation(q[i])\n            T_base_to_ee = T_base_to_ee @ T_joint\n            T_list.append(T_base_to_ee.copy())\n\n        T_ee = T_list[-1]\n        p_ee = T_ee[:3, 3]\n        z_ee = T_ee[:3, 2]\n\n        # Calculate Jacobian columns\n        for i in range(self.num_joints):\n            T_i_to_ee = np.linalg.inv(T_list[i]) @ T_ee\n            p_i_to_ee = T_i_to_ee[:3, 3]\n            z_i = T_list[i][:3, 2]\n\n            if self.dh_parameters[i].joint_type == \'revolute\':\n                # Linear velocity\n                J[:3, i] = np.cross(z_i, p_ee - T_list[i][:3, 3])\n                # Angular velocity\n                J[3:, i] = z_i\n            else:  # prismatic\n                # Linear velocity\n                J[:3, i] = z_i\n                # Angular velocity\n                J[3:, i] = np.zeros(3)\n\n        return J\n\nclass HumanoidKinematics:\n    """Complete humanoid robot kinematics"""\n\n    def __init__(self):\n        # Initialize kinematic chains for each limb\n        self.left_arm = KinematicChain()\n        self.right_arm = KinematicChain()\n        self.left_leg = KinematicChain()\n        self.right_leg = KinematicChain()\n        self.head = KinematicChain()\n\n        self.setup_humanoid_dh()\n\n    def setup_humanoid_dh(self):\n        """Set up DH parameters for humanoid robot"""\n        # Left arm (3 DOF shoulder + 1 DOF elbow + 2 DOF wrist)\n        self.left_arm.add_joint(0,  np.pi/2, 0.2, 0)      # Shoulder pitch\n        self.left_arm.add_joint(0.05,  np.pi/2, 0,  np.pi/2)  # Shoulder roll\n        self.left_arm.add_joint(0.25,  0,      0, 0)      # Shoulder yaw\n        self.left_arm.add_joint(0.25,  0,      0, 0)      # Elbow\n        self.left_arm.add_joint(0,   -np.pi/2, 0.1, 0)      # Wrist pitch\n        self.left_arm.add_joint(0,   np.pi/2,  0, 0)      # Wrist roll\n\n        # Right arm (mirrored)\n        self.right_arm.add_joint(0,  np.pi/2, 0.2, 0)      # Shoulder pitch\n        self.right_arm.add_joint(-0.05, np.pi/2, 0, -np.pi/2) # Shoulder roll\n        self.right_arm.add_joint(0.25,  0,      0, 0)      # Shoulder yaw\n        self.right_arm.add_joint(0.25,  0,      0, 0)      # Elbow\n        self.right_arm.add_joint(0,   -np.pi/2, 0.1, 0)      # Wrist pitch\n        self.right_arm.add_joint(0,   np.pi/2,  0, 0)      # Wrist roll\n\n        # Left leg (3 DOF hip + 1 DOF knee + 2 DOF ankle)\n        self.left_leg.add_joint(0,  np.pi/2, 0, 0)      # Hip yaw\n        self.left_leg.add_joint(0,  np.pi/2, 0, np.pi/2)  # Hip roll\n        self.left_leg.add_joint(0.1, 0,      0, 0)      # Hip pitch\n        self.left_leg.add_joint(-0.3, 0,      0, 0)      # Knee\n        self.left_leg.add_joint(0,  -np.pi/2, 0, 0)      # Ankle pitch\n        self.left_leg.add_joint(0,   np.pi/2,  0.05, 0)   # Ankle roll\n\n        # Right leg (mirrored)\n        self.right_leg.add_joint(0,  np.pi/2, 0, 0)      # Hip yaw\n        self.right_leg.add_joint(0,  np.pi/2, 0, -np.pi/2) # Hip roll\n        self.right_leg.add_joint(0.1, 0,      0, 0)      # Hip pitch\n        self.right_leg.add_joint(-0.3, 0,      0, 0)      # Knee\n        self.right_leg.add_joint(0,  -np.pi/2, 0, 0)      # Ankle pitch\n        self.right_leg.add_joint(0,   np.pi/2,  0.05, 0)   # Ankle roll\n\n        # Head (2 DOF)\n        self.head.add_joint(0.1, np.pi/2, 0, 0)      # Neck pitch\n        self.head.add_joint(0,  -np.pi/2, 0, 0)      # Neck yaw\n\n    def get_arm_jacobian(self, side: str, q: np.ndarray) -> np.ndarray:\n        """Get Jacobian for specified arm"""\n        if side == \'left\':\n            return self.left_arm.get_jacobian(q)\n        elif side == \'right\':\n            return self.right_arm.get_jacobian(q)\n        else:\n            raise ValueError("Side must be \'left\' or \'right\'")\n\n    def get_leg_jacobian(self, side: str, q: np.ndarray) -> np.ndarray:\n        """Get Jacobian for specified leg"""\n        if side == \'left\':\n            return self.left_leg.get_jacobian(q)\n        elif side == \'right\':\n            return self.right_leg.get_jacobian(q)\n        else:\n            raise ValueError("Side must be \'left\' or \'right\'")\n'})})}),"\n",(0,a.jsx)(e.h2,{id:"inverse-kinematics",children:"Inverse Kinematics"}),"\n",(0,a.jsx)(e.h3,{id:"1-numerical-ik-solutions",children:"1. Numerical IK Solutions"}),"\n",(0,a.jsx)(o.A,{title:"Newton-Raphson IK Solver",language:"python",children:(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'import numpy as np\nfrom typing import Tuple, Optional\n\nclass InverseKinematicsSolver:\n    """Numerical inverse kinematics solver"""\n\n    def __init__(self, kinematic_chain: KinematicChain,\n                 max_iterations: int = 100,\n                 tolerance: float = 1e-6,\n                 damping: float = 0.1):\n        self.kinematic_chain = kinematic_chain\n        self.max_iterations = max_iterations\n        self.tolerance = tolerance\n        self.damping = damping  # For damped least squares\n\n    def solve(self, target_pose: np.ndarray,\n              initial_guess: Optional[np.ndarray] = None,\n              joint_limits: Optional[Tuple[np.ndarray, np.ndarray]] = None) -> Tuple[bool, np.ndarray]:\n        """\n        Solve inverse kinematics using damped least squares\n\n        Args:\n            target_pose: 4x4 homogeneous transform\n            initial_guess: Initial joint configuration\n            joint_limits: (lower_bounds, upper_bounds) for joints\n\n        Returns:\n            (success, joint_angles)\n        """\n        # Initial configuration\n        if initial_guess is None:\n            q = np.zeros(self.kinematic_chain.num_joints)\n        else:\n            q = initial_guess.copy()\n\n        # Extract target position and orientation\n        target_pos = target_pose[:3, 3]\n        target_rot = target_pose[:3, :3]\n\n        for iteration in range(self.max_iterations):\n            # Forward kinematics\n            current_pose = self.kinematic_chain.forward_kinematics(q)\n            current_pos = current_pose[:3, 3]\n            current_rot = current_pose[:3, :3]\n\n            # Position error\n            pos_error = target_pos - current_pos\n\n            # Orientation error (axis-angle)\n            rot_error = self.rotation_error(current_rot, target_rot)\n\n            # Combined error vector\n            error = np.concatenate([pos_error, rot_error])\n\n            # Check convergence\n            if np.linalg.norm(error) < self.tolerance:\n                return True, q\n\n            # Get Jacobian\n            J = self.kinematic_chain.get_jacobian(q)\n\n            # Damped least squares solution\n            J_pseudo = J.T @ np.linalg.inv(\n                J @ J.T + self.damping**2 * np.eye(6)\n            )\n\n            # Joint update\n            delta_q = J_pseudo @ error\n\n            # Update joint angles\n            q_new = q + delta_q\n\n            # Apply joint limits if specified\n            if joint_limits is not None:\n                lower_bounds, upper_bounds = joint_limits\n                q_new = np.clip(q_new, lower_bounds, upper_bounds)\n\n            q = q_new\n\n        # Check if solution is acceptable\n        final_pose = self.kinematic_chain.forward_kinematics(q)\n        final_error = np.linalg.norm(\n            target_pose[:3, 3] - final_pose[:3, 3]\n        )\n\n        return final_error < 0.01, q\n\n    @staticmethod\n    def rotation_error(R_current: np.ndarray, R_target: np.ndarray) -> np.ndarray:\n        """Calculate orientation error as axis-angle"""\n        R_error = R_target @ R_current.T\n\n        # Convert to axis-angle\n        angle = np.arccos(\n            np.clip((np.trace(R_error) - 1) / 2, -1, 1)\n        )\n\n        if angle < 1e-6:\n            return np.zeros(3)\n\n        axis = (R_error - R_error.T) / (2 * np.sin(angle))\n        return angle * np.array([axis[2, 1], axis[0, 2], axis[1, 0]])\n\nclass AnalyticalIKSolver:\n    """Analytical inverse kinematics for specific configurations"""\n\n    @staticmethod\n    def solve_2dof_arm(l1: float, l2: float, x: float, y: float,\n                      elbow_up: bool = True) -> Tuple[bool, np.ndarray]:\n        """\n        Analytical IK for 2-DOF planar arm\n\n        Args:\n            l1, l2: Link lengths\n            x, y: Target position\n            elbow_up: Elbow configuration\n\n        Returns:\n            (success, [theta1, theta2])\n        """\n        # Distance to target\n        d = np.sqrt(x**2 + y**2)\n\n        # Check reachability\n        if d > l1 + l2 or d < abs(l1 - l2):\n            return False, np.zeros(2)\n\n        # Law of cosines for elbow angle\n        cos_theta2 = (d**2 - l1**2 - l2**2) / (2 * l1 * l2)\n        cos_theta2 = np.clip(cos_theta2, -1, 1)\n\n        if elbow_up:\n            theta2 = np.arccos(cos_theta2)\n        else:\n            theta2 = -np.arccos(cos_theta2)\n\n        # Shoulder angle\n        k1 = l1 + l2 * np.cos(theta2)\n        k2 = l2 * np.sin(theta2)\n        theta1 = np.arctan2(y, x) - np.arctan2(k2, k1)\n\n        return True, np.array([theta1, theta2])\n\nclass WholeBodyIK:\n    """Whole-body inverse kinematics for humanoid robots"""\n\n    def __init__(self, humanoid_kinematics: HumanoidKinematics):\n        self.humanoid = humanoid_kinematics\n        self.priority_tasks = []\n\n    def add_task(self, task_type: str, priority: int, **kwargs):\n        """Add a prioritized task"""\n        self.priority_tasks.append({\n            \'type\': task_type,\n            \'priority\': priority,\n            \'params\': kwargs\n        })\n\n    def solve_whole_body(self, q_initial: np.ndarray) -> Tuple[bool, np.ndarray]:\n        """Solve whole-body IK with task prioritization"""\n        q = q_initial.copy()\n\n        # Sort tasks by priority (lower number = higher priority)\n        self.priority_tasks.sort(key=lambda x: x[\'priority\'])\n\n        for task in self.priority_tasks:\n            success = self.solve_single_task(task, q)\n            if not success:\n                print(f"Failed to solve task: {task[\'type\']}")\n                # Continue with lower priority tasks\n\n        return True, q\n\n    def solve_single_task(self, task: Dict, q: np.ndarray) -> bool:\n        """Solve a single IK task"""\n        task_type = task[\'type\']\n        params = task[\'params\']\n\n        if task_type == \'reach\':\n            return self.solve_reach_task(q, params)\n        elif task_type == \'foot_placement\':\n            return self.solve_foot_placement(q, params)\n        elif task_type == \'gaze\':\n            return self.solve_gaze_task(q, params)\n        elif task_type == \'center_of_mass\':\n            return self.solve_com_task(q, params)\n        else:\n            print(f"Unknown task type: {task_type}")\n            return False\n\n    def solve_reach_task(self, q: np.ndarray, params: Dict) -> bool:\n        """Solve arm reaching task"""\n        side = params[\'side\']  # \'left\' or \'right\'\n        target = params[\'target\']\n\n        # Get current arm configuration\n        if side == \'left\':\n            arm_kinematics = self.humanoid.left_arm\n            q_start = 6  # Assuming left arm starts at joint 6\n        else:\n            arm_kinematics = self.humanoid.right_arm\n            q_start = 12  # Assuming right arm starts at joint 12\n\n        q_arm = q[q_start:q_start + 6]\n\n        # Solve arm IK\n        ik_solver = InverseKinematicsSolver(arm_kinematics)\n        success, q_arm_sol = ik_solver.solve(target, q_arm)\n\n        if success:\n            q[q_start:q_start + 6] = q_arm_sol\n\n        return success\n\n    def solve_foot_placement(self, q: np.ndarray, params: Dict) -> bool:\n        """Solve foot placement task"""\n        side = params[\'side\']\n        target = params[\'target\']\n\n        # Get leg configuration\n        if side == \'left\':\n            leg_kinematics = self.humanoid.left_leg\n            q_start = 0  # Assuming legs start from beginning\n        else:\n            leg_kinematics = self.humanoid.right_leg\n            q_start = 6  # Assuming right leg starts after left leg\n\n        q_leg = q[q_start:q_start + 6]\n\n        # Solve leg IK\n        ik_solver = InverseKinematicsSolver(leg_kinematics)\n        success, q_leg_sol = ik_solver.solve(target, q_leg)\n\n        if success:\n            q[q_start:q_start + 6] = q_leg_sol\n\n        return success\n\n    def solve_gaze_task(self, q: np.ndarray, params: Dict) -> bool:\n        """Solve gaze direction task"""\n        target_point = params[\'target\']\n        head_joints = q[-2:]  # Assuming head joints are last\n\n        # Simple gaze control (can be improved with optimization)\n        # Calculate desired head angles\n        dx = target_point[0]\n        dy = target_point[1]\n        dz = target_point[2]\n\n        # Pan (yaw) angle\n        pan = np.arctan2(dy, dx)\n\n        # Tilt (pitch) angle\n        distance = np.sqrt(dx**2 + dy**2)\n        tilt = -np.arctan2(dz, distance)\n\n        # Update head joints\n        q[-2:] = [tilt, pan]\n\n        return True\n\n    def solve_com_task(self, q: np.ndarray, params: Dict) -> bool:\n        """Solve center of mass positioning task"""\n        target_com = params[\'target\']\n\n        # Calculate current COM (simplified)\n        current_com = self.calculate_com(q)\n\n        # Calculate COM error\n        com_error = target_com - current_com[:2]  # Only consider x, y\n\n        # Adjust hip positions to shift COM\n        if np.linalg.norm(com_error) > 0.01:\n            # Simple heuristic: shift hips opposite to COM error\n            hip_adjustment = com_error * 0.1\n            q[6] += hip_adjustment[0]  # Left hip roll\n            q[12] += hip_adjustment[0]  # Right hip roll\n\n        return True\n\n    def calculate_com(self, q: np.ndarray) -> np.ndarray:\n        """Calculate center of mass (simplified)"""\n        # This is a simplified COM calculation\n        # In practice, use full mass distribution model\n\n        # Get positions of key joints\n        torso_height = 0.9  # Approximate torso COM height\n        com = np.array([0, 0, torso_height])\n\n        # Adjust based on joint angles (very simplified)\n        com[0] += np.sin(q[7]) * 0.1  # Hip roll effect\n        com[1] += np.sin(q[8]) * 0.1  # Hip pitch effect\n\n        return com\n'})})}),"\n",(0,a.jsx)(e.h2,{id:"lab-exercise-humanoid-motion-planning",children:"Lab Exercise: Humanoid Motion Planning"}),"\n",(0,a.jsxs)("div",{className:"lab-exercise",children:[(0,a.jsx)(e.h3,{id:"objective",children:"Objective"}),(0,a.jsx)(e.p,{children:"Implement a complete kinematic system for a humanoid robot including forward/inverse kinematics, Jacobian calculations, and motion planning."}),(0,a.jsx)(e.h3,{id:"setup",children:"Setup"}),(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsx)(e.li,{children:"Humanoid robot model with 25 DOF"}),"\n",(0,a.jsx)(e.li,{children:"Target reaching tasks"}),"\n",(0,a.jsx)(e.li,{children:"Whole-body motion planning"}),"\n",(0,a.jsx)(e.li,{children:"Simulation visualization"}),"\n"]}),(0,a.jsx)(e.h3,{id:"implementation",children:"Implementation"}),(0,a.jsx)(o.A,{language:"python",editable:!0,children:(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"# humanoid_motion_planner.py\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n\nclass HumanoidMotionPlanner:\n    \"\"\"Motion planner for humanoid robots\"\"\"\n\n    def __init__(self):\n        self.humanoid = HumanoidKinematics()\n        self.ik_solver = InverseKinematicsSolver\n        self.whole_body_ik = WholeBodyIK(self.humanoid)\n\n        # Current joint configuration\n        self.q = np.zeros(25)  # Total DOF: 2(head) + 6(left_arm) + 6(right_arm) + 6(left_leg) + 5(right_leg)\n\n        # Motion constraints\n        self.joint_limits = self.get_joint_limits()\n        self.max_joint_velocity = np.ones(25) * 0.5  # rad/s\n\n    def get_joint_limits(self) -> Tuple[np.ndarray, np.ndarray]:\n        \"\"\"Get joint limits for humanoid robot\"\"\"\n        lower = np.array([\n            # Head\n            -np.pi/3, -np.pi/2,\n            # Left Arm\n            -np.pi, -np.pi/2, -np.pi, -np.pi*2/3, -np.pi/2, -np.pi/2,\n            # Right Arm\n            -np.pi, -np.pi/2, -np.pi, -np.pi*2/3, -np.pi/2, -np.pi/2,\n            # Left Leg\n            -np.pi/4, -np.pi/6, -np.pi/3, 0, -np.pi/6, -np.pi/6,\n            # Right Leg\n            -np.pi/4, -np.pi/6, -np.pi/3, 0, -np.pi/6, -np.pi/6\n        ])\n\n        upper = np.array([\n            # Head\n            np.pi/3, np.pi/2,\n            # Left Arm\n            np.pi, np.pi/2, np.pi, np.pi*2/3, np.pi/2, np.pi/2,\n            # Right Arm\n            np.pi, np.pi/2, np.pi, np.pi*2/3, np.pi/2, np.pi/2,\n            # Left Leg\n            np.pi/4, np.pi/6, np.pi/3, np.pi*2/3, np.pi/6, np.pi/6,\n            # Right Leg\n            np.pi/4, np.pi/6, np.pi/3, np.pi*2/3, np.pi/6, np.pi/6\n        ])\n\n        return lower, upper\n\n    def plan_reach_motion(self, side: str, target_pose: np.ndarray,\n                         duration: float = 2.0) -> Tuple[bool, np.ndarray]:\n        \"\"\"Plan arm reaching motion\"\"\"\n        # Get arm joint indices\n        if side == 'left':\n            arm_start = 2\n        else:\n            arm_start = 8\n\n        arm_end = arm_start + 6\n        q_arm_initial = self.q[arm_start:arm_end]\n\n        # Solve IK for target\n        arm_kinematics = (self.humanoid.left_arm if side == 'left'\n                         else self.humanoid.right_arm)\n        ik_solver = self.ik_solver(arm_kinematics)\n\n        success, q_arm_target = ik_solver.solve(\n            target_pose,\n            q_arm_initial,\n            joint_limits=(self.joint_limits[arm_start:arm_end],\n                        self.joint_limits[arm_start:arm_end])\n        )\n\n        if not success:\n            return False, None\n\n        # Generate trajectory\n        trajectory = self.generate_joint_trajectory(\n            q_arm_initial, q_arm_target, duration\n        )\n\n        return True, trajectory\n\n    def generate_joint_trajectory(self, q_start: np.ndarray,\n                                q_end: np.ndarray,\n                                duration: float) -> np.ndarray:\n        \"\"\"Generate smooth joint trajectory\"\"\"\n        # Number of waypoints\n        num_waypoints = int(duration * 50)  # 50 Hz\n\n        # Time vector\n        t = np.linspace(0, duration, num_waypoints)\n\n        # Minimum-jerk trajectory\n        s = 10 * (t/duration)**3 - 15 * (t/duration)**4 + 6 * (t/duration)**5\n\n        # Interpolate joints\n        trajectory = np.zeros((num_waypoints, len(q_start)))\n        for i in range(len(q_start)):\n            trajectory[:, i] = q_start[i] + s * (q_end[i] - q_start[i])\n\n        return trajectory\n\n    def plan_walking_motion(self, step_length: float = 0.3,\n                           step_height: float = 0.1,\n                           num_steps: int = 2) -> Tuple[bool, np.ndarray]:\n        \"\"\"Plan walking motion\"\"\"\n        trajectory = []\n\n        # Initial pose (standing)\n        q_standing = np.zeros(25)\n        q_standing[8] = 0.2  # Slight bend at hips\n        q_standing[20] = -0.4  # Knee bend\n        q_standing[26] = -0.4  # Knee bend\n        trajectory.append(q_standing)\n\n        # Generate stepping sequence\n        for step in range(num_steps):\n            # Lift foot\n            q_lift = q_standing.copy()\n            if step % 2 == 0:  # Left foot step\n                q_lift[19] -= np.pi/6  # Hip pitch\n                q_lift[20] += np.pi/4  # Knee\n                q_lift[21] += np.pi/6  # Ankle pitch\n            else:  # Right foot step\n                q_lift[25] -= np.pi/6  # Hip pitch\n                q_lift[26] += np.pi/4  # Knee\n                q_lift[27] += np.pi/6  # Ankle pitch\n\n            trajectory.append(q_lift)\n\n            # Step forward\n            q_step = q_standing.copy()\n            if step % 2 == 0:  # Left foot forward\n                q_step[18] = np.pi/8  # Hip yaw\n                q_step[19] = np.pi/6  # Hip pitch\n                q_step[20] = -np.pi/6  # Knee\n            else:  # Right foot forward\n                q_step[24] = -np.pi/8  # Hip yaw\n                q_step[25] = np.pi/6  # Hip pitch\n                q_step[26] = -np.pi/6  # Knee\n\n            trajectory.append(q_step)\n\n            # Return to standing\n            trajectory.append(q_standing)\n\n        # Convert to array and smooth\n        trajectory = np.array(trajectory)\n        smoothed_trajectory = self.smooth_trajectory(trajectory)\n\n        return True, smoothed_trajectory\n\n    def smooth_trajectory(self, trajectory: np.ndarray,\n                         window_size: int = 3) -> np.ndarray:\n        \"\"\"Smooth trajectory using moving average\"\"\"\n        smoothed = np.zeros_like(trajectory)\n\n        for i in range(trajectory.shape[0]):\n            start = max(0, i - window_size)\n            end = min(trajectory.shape[0], i + window_size + 1)\n            smoothed[i] = np.mean(trajectory[start:end], axis=0)\n\n        return smoothed\n\n    def visualize_motion(self, trajectory: np.ndarray):\n        \"\"\"Visualize humanoid motion\"\"\"\n        fig = plt.figure(figsize=(10, 8))\n        ax = fig.add_subplot(111, projection='3d')\n\n        # Draw stick figure for each pose\n        for i, q in enumerate(trajectory[::10]):  # Draw every 10th pose\n            # Get joint positions\n            positions = self.get_joint_positions(q)\n\n            # Draw skeleton\n            self.draw_skeleton(ax, positions, alpha=0.3 + 0.7 * i / len(trajectory))\n\n        ax.set_xlabel('X (m)')\n        ax.set_ylabel('Y (m)')\n        ax.set_zlabel('Z (m)')\n        ax.set_title('Humanoid Motion Trajectory')\n        ax.legend()\n\n        plt.show()\n\n    def get_joint_positions(self, q: np.ndarray) -> Dict[str, np.ndarray]:\n        \"\"\"Get 3D positions of all joints\"\"\"\n        positions = {}\n\n        # Base (origin)\n        positions['pelvis'] = np.array([0, 0, 0])\n\n        # Torso\n        positions['torso'] = np.array([0, 0, 0.5])\n        positions['head'] = np.array([0, 0, 0.8])\n\n        # Arms (simplified)\n        positions['left_shoulder'] = np.array([-0.2, 0, 0.5])\n        positions['left_elbow'] = positions['left_shoulder'] + np.array([-0.25, 0, 0])\n        positions['left_wrist'] = positions['left_elbow'] + np.array([-0.25, 0, 0])\n\n        positions['right_shoulder'] = np.array([0.2, 0, 0.5])\n        positions['right_elbow'] = positions['right_shoulder'] + np.array([0.25, 0, 0])\n        positions['right_wrist'] = positions['right_elbow'] + np.array([0.25, 0, 0])\n\n        # Legs (simplified)\n        positions['left_hip'] = np.array([-0.1, 0, 0])\n        positions['left_knee'] = positions['left_hip'] + np.array([0, 0, -0.3])\n        positions['left_ankle'] = positions['left_knee'] + np.array([0, 0, -0.3])\n\n        positions['right_hip'] = np.array([0.1, 0, 0])\n        positions['right_knee'] = positions['right_hip'] + np.array([0, 0, -0.3])\n        positions['right_ankle'] = positions['right_knee'] + np.array([0, 0, -0.3])\n\n        return positions\n\n    def draw_skeleton(self, ax, positions: Dict[str, np.ndarray],\n                     alpha: float = 1.0, color: str = 'blue'):\n        \"\"\"Draw stick figure skeleton\"\"\"\n        # Define connections between joints\n        connections = [\n            ('pelvis', 'torso'),\n            ('torso', 'head'),\n            ('torso', 'left_shoulder'),\n            ('left_shoulder', 'left_elbow'),\n            ('left_elbow', 'left_wrist'),\n            ('torso', 'right_shoulder'),\n            ('right_shoulder', 'right_elbow'),\n            ('right_elbow', 'right_wrist'),\n            ('pelvis', 'left_hip'),\n            ('left_hip', 'left_knee'),\n            ('left_knee', 'left_ankle'),\n            ('pelvis', 'right_hip'),\n            ('right_hip', 'right_knee'),\n            ('right_knee', 'right_ankle')\n        ]\n\n        # Draw connections\n        for connection in connections:\n            p1 = positions[connection[0]]\n            p2 = positions[connection[1]]\n            ax.plot([p1[0], p2[0]], [p1[1], p2[1]], [p1[2], p2[2]],\n                   color=color, alpha=alpha, linewidth=2)\n\n        # Draw joints\n        for joint_name, pos in positions.items():\n            ax.scatter(pos[0], pos[1], pos[2],\n                      color=color, alpha=alpha, s=20)\n\n# Demo\ndef main():\n    planner = HumanoidMotionPlanner()\n\n    print(\"=== Humanoid Motion Planning Demo ===\")\n\n    # Test 1: Arm reaching\n    print(\"\\n1. Planning arm reaching motion...\")\n    target_pose = HomogeneousTransform.from_rpy(\n        roll=0, pitch=np.pi/2, yaw=0,\n        x=0.4, y=-0.3, z=0.6\n    )\n\n    success, trajectory = planner.plan_reach_motion('left', target_pose)\n\n    if success:\n        print(f\"Success! Trajectory has {len(trajectory)} waypoints\")\n        planner.visualize_motion(trajectory.reshape(-1, 25))\n    else:\n        print(\"Failed to plan reaching motion\")\n\n    # Test 2: Walking motion\n    print(\"\\n2. Planning walking motion...\")\n    success, walk_trajectory = planner.plan_walking_motion(\n        step_length=0.2,\n        num_steps=2\n    )\n\n    if success:\n        print(f\"Success! Walking trajectory has {len(walk_trajectory)} waypoints\")\n        planner.visualize_motion(walk_trajectory)\n    else:\n        print(\"Failed to plan walking motion\")\n\nif __name__ == \"__main__\":\n    main()\n"})})}),(0,a.jsx)(e.h3,{id:"testing-the-motion-planner",children:"Testing the Motion Planner"}),(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Arm Reaching Test"}),":"]}),"\n"]}),(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"# Test reaching to different positions\ntargets = [\n    (0.5, 0, 0.5),  # Front\n    (0, 0.3, 0.6),  # Side\n    (0.4, 0.2, 0.3)  # Diagonal\n]\n\nfor target in targets:\n    pose = HomogeneousTransform.create_translation(*target)\n    success, traj = planner.plan_reach_motion('right', pose)\n"})}),(0,a.jsxs)(e.ol,{start:"2",children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Walking Pattern Test"}),":"]}),"\n"]}),(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"# Test different walking patterns\nsuccess, traj = planner.plan_walking_motion(\n    step_length=0.25,\n    step_height=0.08,\n    num_steps=4\n)\n"})}),(0,a.jsxs)(e.ol,{start:"3",children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Whole-body Tasks Test"}),":"]}),"\n"]}),(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"# Test multi-task planning\nplanner.whole_body_ik.add_task('reach', priority=1,\n                               side='left',\n                               target=left_target)\nplanner.whole_body_ik.add_task('gaze', priority=2,\n                               target=gaze_point)\nplanner.whole_body_ik.add_task('center_of_mass', priority=3,\n                               target=[0, 0])\n"})}),(0,a.jsx)(e.h3,{id:"expected-results",children:"Expected Results"}),(0,a.jsx)(e.p,{children:"The motion planner should demonstrate:"}),(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Accurate inverse kinematics solutions"}),"\n",(0,a.jsx)(e.li,{children:"Smooth joint trajectories"}),"\n",(0,a.jsx)(e.li,{children:"Whole-body coordination"}),"\n",(0,a.jsx)(e.li,{children:"Constraint satisfaction"}),"\n",(0,a.jsx)(e.li,{children:"Real-time performance"}),"\n"]})]}),"\n",(0,a.jsx)(e.h2,{id:"advanced-topics",children:"Advanced Topics"}),"\n",(0,a.jsx)(e.h3,{id:"1-kinematic-redundancy",children:"1. Kinematic Redundancy"}),"\n",(0,a.jsx)(o.A,{title:"Redundancy Resolution",language:"python",children:(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'class RedundantKinematics:\n    """Handle kinematic redundancy using null space projection"""\n\n    def __init__(self, kinematic_chain: KinematicChain):\n        self.chain = kinematic_chain\n        self.num_joints = kinematic_chain.num_joints\n        self.num_tasks = 6  # 3 position + 3 orientation\n\n    def solve_redundant_ik(self, q: np.ndarray, target_pose: np.ndarray,\n                          secondary_tasks: List[Dict] = None) -> Tuple[bool, np.ndarray]:\n        """\n        Solve IK with redundant joints using null space projection\n\n        Args:\n            q: Current joint configuration\n            target_pose: Desired end-effector pose\n            secondary_tasks: List of secondary objectives\n        """\n        for iteration in range(100):\n            # Current pose\n            current_pose = self.chain.forward_kinematics(q)\n\n            # Primary task error\n            error = self.calculate_error(current_pose, target_pose)\n\n            if np.linalg.norm(error) < 1e-6:\n                return True, q\n\n            # Primary task Jacobian\n            J = self.chain.get_jacobian(q)\n\n            # Primary task solution\n            if self.num_joints > self.num_tasks:\n                # Redundant case\n                J_pinv = np.linalg.pinv(J)\n                q_primary = J_pinv @ error\n\n                # Null space projection\n                N = np.eye(self.num_joints) - J_pinv @ J\n\n                # Secondary tasks in null space\n                q_secondary = np.zeros(self.num_joints)\n                if secondary_tasks:\n                    for task in secondary_tasks:\n                        grad = self.task_gradient(q, task)\n                        q_secondary += 0.1 * (N @ grad)\n\n                # Update\n                q = q + q_primary + q_secondary\n            else:\n                # Non-redundant case\n                q = q + np.linalg.pinv(J) @ error\n\n        return False, q\n\n    def calculate_error(self, current_pose: np.ndarray,\n                       target_pose: np.ndarray) -> np.ndarray:\n        """Calculate pose error"""\n        pos_error = target_pose[:3, 3] - current_pose[:3, 3]\n        rot_error = 0.5 * (np.cross(current_pose[:3, 2], target_pose[:3, 2]) +\n                           np.cross(current_pose[:3, 1], target_pose[:3, 1]) +\n                           np.cross(current_pose[:3, 0], target_pose[:3, 0]))\n        return np.concatenate([pos_error, rot_error])\n\n    def task_gradient(self, q: np.ndarray, task: Dict) -> np.ndarray:\n        """Calculate gradient for secondary task"""\n        task_type = task[\'type\']\n\n        if task_type == \'joint_limit\':\n            return self.joint_limit_gradient(q, task[\'limits\'])\n        elif task_type == \'manipulability\':\n            return self.manipulability_gradient(q)\n        elif task_type == \'collision\':\n            return self.collision_gradient(q, task[\'obstacles\'])\n        else:\n            return np.zeros(self.num_joints)\n\n    def joint_limit_gradient(self, q: np.ndarray,\n                            limits: Tuple[np.ndarray, np.ndarray]) -> np.ndarray:\n        """Gradient to avoid joint limits"""\n        lower, upper = limits\n        gradient = np.zeros_like(q)\n\n        for i in range(len(q)):\n            # Near lower limit\n            if q[i] < lower[i] + 0.1:\n                gradient[i] = 100 * (lower[i] + 0.1 - q[i])\n\n            # Near upper limit\n            if q[i] > upper[i] - 0.1:\n                gradient[i] = 100 * (q[i] - (upper[i] - 0.1))\n\n        return gradient\n\n    def manipulability_gradient(self, q: np.ndarray) -> np.ndarray:\n        """Gradient to maximize manipulability"""\n        J = self.chain.get_jacobian(q)\n        manipulability = np.sqrt(np.linalg.det(J @ J.T))\n\n        if manipulability < 1e-6:\n            return np.zeros(self.num_joints)\n\n        # Numerical gradient\n        eps = 1e-6\n        gradient = np.zeros(self.num_joints)\n\n        for i in range(self.num_joints):\n            q_plus = q.copy()\n            q_plus[i] += eps\n\n            J_plus = self.chain.get_jacobian(q_plus)\n            manip_plus = np.sqrt(np.linalg.det(J_plus @ J_plus.T))\n\n            gradient[i] = (manip_plus - manipulability) / eps\n\n        return -gradient  # Negative to maximize\n\n    def collision_gradient(self, q: np.ndarray,\n                          obstacles: List[Dict]) -> np.ndarray:\n        """Gradient to avoid collisions (simplified)"""\n        gradient = np.zeros(self.num_joints)\n\n        # Get end-effector position\n        T = self.chain.forward_kinematics(q)\n        ee_pos = T[:3, 3]\n\n        for obs in obstacles:\n            obs_pos = obs[\'position\']\n            obs_radius = obs[\'radius\']\n\n            # Distance to obstacle\n            dist = np.linalg.norm(ee_pos - obs_pos)\n\n            # Repulsive potential\n            if dist < obs_radius + 0.1:\n                # Calculate gradient\n                direction = (ee_pos - obs_pos) / dist\n                potential = 1.0 / (dist - obs_radius + 0.01)\n\n                # Simple approximation of Jacobian\n                J = self.chain.get_jacobian(q)\n                gradient += potential * J[:3, :].T @ direction\n\n        return gradient\n'})})}),"\n",(0,a.jsx)(e.h3,{id:"2-singularity-analysis",children:"2. Singularity Analysis"}),"\n",(0,a.jsx)(o.A,{title:"Singularity Detection",language:"python",children:(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'class SingularityAnalysis:\n    """Analyze and avoid singularities in humanoid robots"""\n\n    @staticmethod\n    def check_manipulability(J: np.ndarray) -> Tuple[float, bool]:\n        """\n        Check manipulability measure\n\n        Returns:\n            (manipulability, is_near_singularity)\n        """\n        # Calculate manipulability\n        manipulability = np.sqrt(np.linalg.det(J @ J.T))\n\n        # Check if near singularity\n        threshold = 0.01  # Adjust based on robot\n        is_near_singularity = manipulability < threshold\n\n        return manipulability, is_near_singularity\n\n    @staticmethod\n    def get_singular_values(J: np.ndarray) -> np.ndarray:\n        """Get singular values of Jacobian"""\n        return np.linalg.svd(J, compute_uv=False)\n\n    @staticmethod\n    def classify_singularities(J: np.ndarray, q: np.ndarray) -> str:\n        """Classify type of singularity"""\n        singular_values = SingularityAnalysis.get_singular_values(J)\n\n        # Count near-zero singular values\n        threshold = 1e-6\n        zero_sv_count = np.sum(singular_values < threshold)\n\n        if zero_sv_count == 0:\n            return "regular"\n        elif zero_sv_count == 1:\n            return "isolated"\n        elif zero_sv_count == 2:\n            return "boundary"\n        else:\n            return "complex"\n\n    @staticmethod\n    def avoid_singularities(J: np.ndarray, error: np.ndarray,\n                           lambda_min: float = 0.001,\n                           lambda_max: float = 0.1) -> np.ndarray:\n        """\n        Damped least squares to avoid singularities\n\n        Uses variable damping based on manipulability\n        """\n        manipulability, is_singular = SingularityAnalysis.check_manipulability(J)\n\n        # Adaptive damping\n        if is_singular:\n            lambda_damp = lambda_max\n        else:\n            # Scale damping based on manipulability\n            w = (manipulability - 0.01) / 0.99  # Normalize to [0, 1]\n            lambda_damp = lambda_min + (1 - w) * (lambda_max - lambda_min)\n\n        # Damped least squares solution\n        J_damped = J.T @ J + lambda_damp**2 * np.eye(J.shape[1])\n        q_dot = np.linalg.solve(J_damped, J.T @ error)\n\n        return q_dot\n\nclass SingularityAvoidanceController:\n    """Controller with singularity avoidance"""\n\n    def __init__(self, kinematic_chain: KinematicChain):\n        self.chain = kinematic_chain\n        self.analysis = SingularityAnalysis()\n\n    def compute_joint_velocities(self, q: np.ndarray,\n                                target_pose: np.ndarray) -> np.ndarray:\n        """Compute joint velocities with singularity avoidance"""\n        # Current pose\n        current_pose = self.chain.forward_kinematics(q)\n\n        # Error\n        error = self.calculate_pose_error(current_pose, target_pose)\n\n        # Jacobian\n        J = self.chain.get_jacobian(q)\n\n        # Check for singularities\n        manipulability, is_singular = self.analysis.check_manipulability(J)\n\n        if is_singular:\n            print(f"Warning: Near singularity! Manipulability = {manipulability:.6f}")\n\n            # Use damped least squares\n            q_dot = self.analysis.avoid_singularities(J, error)\n        else:\n            # Regular inverse kinematics\n            q_dot = np.linalg.pinv(J) @ error\n\n        return q_dot\n\n    def calculate_pose_error(self, current_pose: np.ndarray,\n                           target_pose: np.ndarray) -> np.ndarray:\n        """Calculate 6D pose error"""\n        # Position error\n        pos_error = target_pose[:3, 3] - current_pose[:3, 3]\n\n        # Orientation error (simplified)\n        rot_error = 0.5 * self.angle_axis_from_matrix(\n            target_pose[:3, :3] @ current_pose[:3, :3].T\n        )\n\n        return np.concatenate([pos_error, rot_error])\n\n    @staticmethod\n    def angle_axis_from_matrix(R: np.ndarray) -> np.ndarray:\n        """Convert rotation matrix to angle-axis"""\n        angle = np.arccos(np.clip((np.trace(R) - 1) / 2, -1, 1))\n\n        if angle < 1e-6:\n            return np.zeros(3)\n\n        axis = np.array([\n            R[2, 1] - R[1, 2],\n            R[0, 2] - R[2, 0],\n            R[1, 0] - R[0, 1]\n        ]) / (2 * np.sin(angle))\n\n        return angle * axis\n'})})}),"\n",(0,a.jsx)(e.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"DH parameters"})," provide a systematic way to model complex kinematic chains"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Forward kinematics"})," computes end-effector pose from joint angles"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Inverse kinematics"})," finds joint configurations for desired poses"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Jacobian matrices"})," relate joint velocities to end-effector velocities"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Singularity analysis"})," is crucial for robust robot control"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Redundancy resolution"})," enables optimization of secondary objectives"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,a.jsx)(e.p,{children:"Humanoid robot kinematics is the mathematical foundation for controlling complex robots with many degrees of freedom. By understanding forward/inverse kinematics, Jacobians, and singularity analysis, we can create sophisticated motion planning systems that enable humanoid robots to perform complex tasks with human-like dexterity."}),"\n",(0,a.jsxs)(e.p,{children:["In the next lesson, we'll explore ",(0,a.jsx)(e.strong,{children:"Biped Locomotion"})," - the art of making humanoid robots walk."]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.a,{href:"lesson-2",children:"Next: Biped Locomotion \u2192"})}),"\n",(0,a.jsx)(e.h2,{id:"quiz",children:"Quiz"}),"\n",(0,a.jsx)(i,{quizId:"humanoid-robot-kinematics",questions:[{id:"q1",type:"multiple-choice",question:"What is the primary advantage of using Denavit-Hartenberg parameters?",options:["They reduce computational complexity","They provide a systematic way to describe any serial manipulator","They eliminate singularities","They automatically optimize joint configurations"],correct:1,explanation:"DH parameters provide a standardized, systematic method for describing the geometry of any serial manipulator chain using just four parameters per joint."},{id:"q2",type:"multiple-choice",question:"What does the Jacobian matrix relate in robot kinematics?",options:["Joint angles to joint velocities","Joint velocities to end-effector velocities","End-effector position to joint angles","Time to position"],correct:1,explanation:"The Jacobian matrix maps joint velocities to end-effector velocities (both linear and angular), providing the differential kinematics relationship."},{id:"q3",type:"true-false",question:"A humanoid robot with more than 6 degrees of freedom in its arm is redundant.",correct:!0,explanation:"Since 6 DOF are sufficient to achieve any position and orientation in 3D space, any additional DOF beyond 6 provide redundancy, allowing for optimization of secondary objectives."}]})]})}function m(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(d,{...n})}):d(n)}function _(n,e){throw new Error("Expected "+(e?"component":"object")+" `"+n+"` to be defined: you likely forgot to import, pass, or provide it.")}},8453:(n,e,t)=>{t.d(e,{R:()=>o,x:()=>s});var i=t(6540);const a={},r=i.createContext(a);function o(n){const e=i.useContext(r);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:o(n.components),i.createElement(r.Provider,{value:e},n.children)}}}]);